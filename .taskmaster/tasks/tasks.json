{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup and Configuration Management",
        "description": "Set up the TypeScript project structure with Node.js and implement the configuration loader for reading and validating the config.json file.",
        "details": "1. Initialize a new Node.js project with TypeScript\n2. Set up project structure with directories for services, models, utils, etc.\n3. Configure tsconfig.json for TypeScript compilation\n4. Implement ConfigLoader class to read and parse config.json\n5. Create TypeScript interfaces for configuration objects\n6. Implement validation for configuration parameters\n7. Set up environment variables handling for API keys using dotenv\n8. Create a basic logging system using winston\n\nExample ConfigLoader implementation:\n```typescript\nimport fs from 'fs';\nimport path from 'path';\nimport dotenv from 'dotenv';\nimport { z } from 'zod';\n\n// Load environment variables\ndotenv.config();\n\n// Define configuration schema using Zod\nconst ConfigSchema = z.object({\n  tradeMode: z.enum(['backtest', 'papertrade', 'live']),\n  exchange: z.literal('binance'),\n  maxBudget: z.object({\n    amount: z.number().positive(),\n    currency: z.string()\n  }),\n  symbols: z.array(z.object({\n    pair: z.string(),\n    minDailyBarDiffThreshold: z.number().positive()\n  })),\n  apiKeys: z.object({\n    binanceApiKey: z.string(),\n    binanceSecretKey: z.string(),\n    telegramBotToken: z.string().optional(),\n    telegramChatId: z.string().optional()\n  }),\n  strategySettings: z.object({\n    barCountForVolatility: z.number().int().positive(),\n    minVolatilityPercentage: z.number().positive(),\n    minVolatileBarRatio: z.number().positive(),\n    emaPeriod: z.number().int().positive(),\n    emaDeviationThreshold: z.number().positive()\n  }),\n  binanceSettings: z.object({\n    testnet: z.boolean(),\n    commissionRate: z.number().positive()\n  }),\n  logging: z.object({\n    enableConsoleOutput: z.boolean(),\n    enableTelegramOutput: z.boolean(),\n    reportDirectory: z.string(),\n    transactionLogFileName: z.string()\n  })\n});\n\nexport type BotConfig = z.infer<typeof ConfigSchema>;\n\nexport class ConfigLoader {\n  static loadConfig(configPath: string): BotConfig {\n    try {\n      const configData = fs.readFileSync(path.resolve(configPath), 'utf8');\n      const parsedConfig = JSON.parse(configData);\n      \n      // Replace API keys with environment variables if available\n      if (process.env.BINANCE_API_KEY) {\n        parsedConfig.apiKeys.binanceApiKey = process.env.BINANCE_API_KEY;\n      }\n      if (process.env.BINANCE_SECRET_KEY) {\n        parsedConfig.apiKeys.binanceSecretKey = process.env.BINANCE_SECRET_KEY;\n      }\n      if (process.env.TELEGRAM_BOT_TOKEN) {\n        parsedConfig.apiKeys.telegramBotToken = process.env.TELEGRAM_BOT_TOKEN;\n      }\n      if (process.env.TELEGRAM_CHAT_ID) {\n        parsedConfig.apiKeys.telegramChatId = process.env.TELEGRAM_CHAT_ID;\n      }\n      \n      // Validate configuration\n      return ConfigSchema.parse(parsedConfig);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        console.error('Configuration validation failed:', error.errors);\n      } else {\n        console.error('Failed to load configuration:', error);\n      }\n      throw error;\n    }\n  }\n}\n```",
        "testStrategy": "1. Write unit tests for ConfigLoader using Jest\n2. Test validation of correct and incorrect configuration files\n3. Test environment variable overrides for API keys\n4. Test handling of missing or malformed config.json\n5. Verify that the loaded configuration matches the expected structure",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Binance API Service Implementation",
        "description": "Develop a service to interact with Binance Spot API for fetching market data, account information, and executing trades.",
        "details": "1. Create a BinanceService class that handles all interactions with Binance API\n2. Implement methods for fetching historical and real-time market data\n3. Implement methods for account information (balances, open orders)\n4. Implement methods for order management (create, cancel, query)\n5. Handle Binance-specific error codes and rate limiting\n6. Implement WebSocket connections for real-time data\n7. Add support for both mainnet and testnet environments\n\nExample implementation:\n```typescript\nimport Binance from 'node-binance-api';\nimport { BotConfig } from '../config/ConfigLoader';\n\nexport class BinanceService {\n  private binance: any;\n  private config: BotConfig;\n\n  constructor(config: BotConfig) {\n    this.config = config;\n    this.binance = new Binance().options({\n      APIKEY: config.apiKeys.binanceApiKey,\n      APISECRET: config.apiKeys.binanceSecretKey,\n      useServerTime: true,\n      test: config.binanceSettings.testnet\n    });\n  }\n\n  async getHistoricalKlines(symbol: string, interval: string, startTime: number, endTime: number): Promise<any[]> {\n    try {\n      return await this.binance.candlesticks(symbol, interval, false, {\n        startTime,\n        endTime,\n        limit: 1000\n      });\n    } catch (error) {\n      console.error(`Error fetching historical klines for ${symbol}:`, error);\n      throw error;\n    }\n  }\n\n  async getAccountBalance(): Promise<any> {\n    try {\n      return await this.binance.balance();\n    } catch (error) {\n      console.error('Error fetching account balance:', error);\n      throw error;\n    }\n  }\n\n  async createOrder(symbol: string, side: 'BUY' | 'SELL', type: string, quantity: number, price?: number): Promise<any> {\n    try {\n      if (type === 'LIMIT' && price) {\n        return await this.binance.buy(symbol, quantity, price);\n      } else if (type === 'MARKET') {\n        return side === 'BUY' \n          ? await this.binance.marketBuy(symbol, quantity)\n          : await this.binance.marketSell(symbol, quantity);\n      }\n      throw new Error(`Unsupported order type: ${type}`);\n    } catch (error) {\n      console.error(`Error creating ${side} order for ${symbol}:`, error);\n      throw error;\n    }\n  }\n\n  async cancelOrder(symbol: string, orderId: number): Promise<any> {\n    try {\n      return await this.binance.cancel(symbol, orderId);\n    } catch (error) {\n      console.error(`Error canceling order ${orderId} for ${symbol}:`, error);\n      throw error;\n    }\n  }\n\n  subscribeToKlineUpdates(symbol: string, interval: string, callback: (kline: any) => void): void {\n    this.binance.websockets.candlesticks(symbol, interval, (candlesticks: any) => {\n      const { e: eventType, k: kline } = candlesticks;\n      callback(kline);\n    });\n  }\n\n  // Add methods for checking Binance's minimum notional, lot size, and price precision\n  async getExchangeInfo(): Promise<any> {\n    try {\n      return await this.binance.exchangeInfo();\n    } catch (error) {\n      console.error('Error fetching exchange info:', error);\n      throw error;\n    }\n  }\n}\n```",
        "testStrategy": "1. Write unit tests for BinanceService using Jest with mocked API responses\n2. Test error handling for various Binance API error scenarios\n3. Test rate limiting and retry mechanisms\n4. Test WebSocket connection and data handling\n5. Create integration tests using Binance testnet\n6. Verify correct handling of minimum order sizes and precision requirements",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Grid Strategy Engine Implementation",
        "description": "Develop the core grid strategy engine that calculates grid levels, determines entry/exit points, and manages the trading logic.",
        "details": "1. Create a StrategyEngine class that implements the grid trading strategy\n2. Implement methods for calculating grid intervals using ATR and daily bar difference methods\n3. Implement dynamic position sizing with DCA logic\n4. Add price filtering based on EMA deviation\n5. Implement profit taking logic with commission optimization\n6. Create interfaces for strategy parameters and trading signals\n\nExample implementation:\n```typescript\nimport { BotConfig } from '../config/ConfigLoader';\nimport { calculateATR, calculateEMA } from '../utils/indicators';\n\nexport interface GridLevel {\n  price: number;\n  buySize: number;\n  sellSize: number;\n  status: 'pending' | 'filled' | 'canceled';\n  orderId?: number;\n}\n\nexport interface StrategyState {\n  symbol: string;\n  gridLevels: GridLevel[];\n  currentPrice: number;\n  ema200: number;\n  atr: number;\n  lastGridRecalculationTime: number;\n  totalProfit: number;\n  openPositions: Map<number, any>; // Grid level index to position details\n}\n\nexport class StrategyEngine {\n  private config: BotConfig;\n  private strategyStates: Map<string, StrategyState> = new Map();\n\n  constructor(config: BotConfig) {\n    this.config = config;\n  }\n\n  initializeStrategy(symbol: string, historicalData: any[]): void {\n    // Calculate initial indicators\n    const atr = this.calculateGridInterval(historicalData, 'ATR');\n    const ema200 = calculateEMA(historicalData, this.config.strategySettings.emaPeriod);\n    const currentPrice = historicalData[historicalData.length - 1].close;\n    \n    // Initialize strategy state\n    this.strategyStates.set(symbol, {\n      symbol,\n      gridLevels: [],\n      currentPrice,\n      ema200,\n      atr,\n      lastGridRecalculationTime: Date.now(),\n      totalProfit: 0,\n      openPositions: new Map()\n    });\n    \n    // Calculate initial grid levels\n    this.recalculateGridLevels(symbol);\n  }\n\n  calculateGridInterval(historicalData: any[], method: 'ATR' | 'DailyBarDiff'): number {\n    if (method === 'ATR') {\n      return calculateATR(historicalData, 14); // 14-period ATR\n    } else {\n      // Daily Bar Difference method\n      const barCount = this.config.strategySettings.barCountForVolatility;\n      const bars = historicalData.slice(-barCount);\n      \n      let totalDiff = 0;\n      let volatileBarCount = 0;\n      \n      bars.forEach(bar => {\n        const diff = Math.abs(bar.close - bar.open);\n        totalDiff += diff;\n        \n        if (diff / bar.open > this.config.strategySettings.minVolatilityPercentage) {\n          volatileBarCount++;\n        }\n      });\n      \n      const avgBarDiff = totalDiff / barCount;\n      const volatileBarRatio = volatileBarCount / barCount;\n      \n      // Check if volatility criteria is met\n      if (volatileBarRatio < this.config.strategySettings.minVolatileBarRatio) {\n        return 0; // Not enough volatility\n      }\n      \n      return avgBarDiff / 4; // Grid interval is 1/4 of average bar difference\n    }\n  }\n\n  recalculateGridLevels(symbol: string): void {\n    const state = this.strategyStates.get(symbol);\n    if (!state) return;\n    \n    const { currentPrice, atr } = state;\n    const symbolConfig = this.config.symbols.find(s => s.pair === symbol);\n    \n    if (!symbolConfig || atr < symbolConfig.minDailyBarDiffThreshold) {\n      console.log(`Skipping ${symbol} due to insufficient volatility`);\n      return;\n    }\n    \n    // Calculate grid levels around current price\n    const gridLevels: GridLevel[] = [];\n    const gridCount = 10; // Number of grid levels above and below current price\n    \n    for (let i = -gridCount; i <= gridCount; i++) {\n      const price = currentPrice + (i * atr);\n      \n      // Determine position size with DCA logic\n      let buySize = 1000; // Default position size in USDT\n      \n      // Apply DCA logic: 80% standard size, 10% 3x size, 10% 4x size\n      if (i <= -8) { // Bottom 10% of grid levels\n        buySize = 4000; // 4x size for deep dips\n      } else if (i <= -5) { // Next 30% of grid levels\n        buySize = 3000; // 3x size for moderate dips\n      }\n      \n      gridLevels.push({\n        price,\n        buySize,\n        sellSize: 0, // Will be set when buy orders are filled\n        status: 'pending'\n      });\n    }\n    \n    state.gridLevels = gridLevels;\n    state.lastGridRecalculationTime = Date.now();\n  }\n\n  shouldTradeBasedOnEMA(symbol: string): boolean {\n    const state = this.strategyStates.get(symbol);\n    if (!state) return false;\n    \n    const { currentPrice, ema200 } = state;\n    const deviation = Math.abs(currentPrice - ema200) / ema200;\n    \n    // Only trade if price is within EMA deviation threshold\n    return deviation <= this.config.strategySettings.emaDeviationThreshold;\n  }\n\n  updateState(symbol: string, latestBar: any): void {\n    const state = this.strategyStates.get(symbol);\n    if (!state) return;\n    \n    state.currentPrice = latestBar.close;\n    \n    // Check if we need to recalculate grid levels (every 2 days)\n    const twoDaysMs = 2 * 24 * 60 * 60 * 1000;\n    if (Date.now() - state.lastGridRecalculationTime > twoDaysMs) {\n      this.recalculateGridLevels(symbol);\n    }\n  }\n\n  getTradeSignals(symbol: string): { buy: GridLevel[], sell: GridLevel[] } {\n    const state = this.strategyStates.get(symbol);\n    if (!state) return { buy: [], sell: [] };\n    \n    // Skip trading if outside EMA threshold\n    if (!this.shouldTradeBasedOnEMA(symbol)) {\n      return { buy: [], sell: [] };\n    }\n    \n    const buySignals: GridLevel[] = [];\n    const sellSignals: GridLevel[] = [];\n    \n    // Find grid levels to trade\n    state.gridLevels.forEach(level => {\n      if (level.status === 'pending') {\n        if (level.price < state.currentPrice) {\n          // Buy when price is above grid level\n          buySignals.push(level);\n        } else if (level.price > state.currentPrice) {\n          // Sell when price is below grid level (if we have position)\n          if (level.sellSize > 0) {\n            sellSignals.push(level);\n          }\n        }\n      }\n    });\n    \n    return { buy: buySignals, sell: sellSignals };\n  }\n\n  calculateProfitTarget(entryPrice: number, gridInterval: number): number {\n    // Target 4 grid intervals of gross profit\n    // 2 intervals for commission, 2 for net profit\n    return entryPrice + (4 * gridInterval);\n  }\n}\n```",
        "testStrategy": "1. Write unit tests for all strategy calculation methods\n2. Test grid interval calculations with different market conditions\n3. Test EMA filtering logic with various price scenarios\n4. Test DCA position sizing logic\n5. Test profit target calculations including commission considerations\n6. Verify grid recalculation timing logic",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Backtesting Module Implementation",
        "description": "Develop the backtesting module that simulates the grid strategy on historical data and generates performance reports.",
        "details": "1. Create a Backtester class that simulates trading on historical data\n2. Implement methods for loading historical data from Binance API or local files\n3. Simulate order execution with realistic slippage and commission\n4. Track performance metrics (profit/loss, win rate, drawdown)\n5. Generate detailed reports in JSON and CSV formats\n\nExample implementation:\n```typescript\nimport fs from 'fs';\nimport path from 'path';\nimport { BotConfig } from '../config/ConfigLoader';\nimport { BinanceService } from '../services/BinanceService';\nimport { StrategyEngine } from '../services/StrategyEngine';\nimport { ReportService } from '../services/ReportService';\n\ninterface BacktestResult {\n  symbol: string;\n  startTime: number;\n  endTime: number;\n  initialBalance: number;\n  finalBalance: number;\n  totalProfit: number;\n  totalProfitPercentage: number;\n  totalTrades: number;\n  winningTrades: number;\n  losingTrades: number;\n  winRate: number;\n  maxDrawdown: number;\n  trades: any[];\n}\n\nexport class Backtester {\n  private config: BotConfig;\n  private binanceService: BinanceService;\n  private strategyEngine: StrategyEngine;\n  private reportService: ReportService;\n\n  constructor(\n    config: BotConfig,\n    binanceService: BinanceService,\n    strategyEngine: StrategyEngine,\n    reportService: ReportService\n  ) {\n    this.config = config;\n    this.binanceService = binanceService;\n    this.strategyEngine = strategyEngine;\n    this.reportService = reportService;\n  }\n\n  async loadHistoricalData(symbol: string, interval: string, startTime: number, endTime: number): Promise<any[]> {\n    // Try to load from local file first\n    const fileName = `${symbol.replace('/', '')}_${interval}_${startTime}_${endTime}.json`;\n    const filePath = path.join(this.config.logging.reportDirectory, 'historical_data', fileName);\n    \n    try {\n      if (fs.existsSync(filePath)) {\n        const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));\n        console.log(`Loaded historical data for ${symbol} from local file`);\n        return data;\n      }\n    } catch (error) {\n      console.warn(`Could not load historical data from file: ${error.message}`);\n    }\n    \n    // Fetch from Binance API\n    console.log(`Fetching historical data for ${symbol} from Binance API`);\n    const data = await this.binanceService.getHistoricalKlines(symbol, interval, startTime, endTime);\n    \n    // Save to file for future use\n    try {\n      fs.mkdirSync(path.dirname(filePath), { recursive: true });\n      fs.writeFileSync(filePath, JSON.stringify(data));\n      console.log(`Saved historical data for ${symbol} to local file`);\n    } catch (error) {\n      console.warn(`Could not save historical data to file: ${error.message}`);\n    }\n    \n    return data;\n  }\n\n  async runBacktest(startTime: number, endTime: number): Promise<Map<string, BacktestResult>> {\n    const results = new Map<string, BacktestResult>();\n    \n    for (const symbolConfig of this.config.symbols) {\n      const symbol = symbolConfig.pair;\n      console.log(`Starting backtest for ${symbol}...`);\n      \n      // Load historical data\n      const historicalData = await this.loadHistoricalData(symbol, '1m', startTime, endTime);\n      \n      // Initialize strategy with historical data\n      this.strategyEngine.initializeStrategy(symbol, historicalData.slice(0, 500));\n      \n      // Initialize backtest result\n      const result: BacktestResult = {\n        symbol,\n        startTime,\n        endTime,\n        initialBalance: this.config.maxBudget.amount,\n        finalBalance: this.config.maxBudget.amount,\n        totalProfit: 0,\n        totalProfitPercentage: 0,\n        totalTrades: 0,\n        winningTrades: 0,\n        losingTrades: 0,\n        winRate: 0,\n        maxDrawdown: 0,\n        trades: []\n      };\n      \n      let balance = this.config.maxBudget.amount;\n      let highestBalance = balance;\n      let currentDrawdown = 0;\n      let maxDrawdown = 0;\n      \n      // Simulate trading on each candle\n      for (let i = 500; i < historicalData.length; i++) {\n        const bar = historicalData[i];\n        \n        // Update strategy state with latest bar\n        this.strategyEngine.updateState(symbol, bar);\n        \n        // Get trade signals\n        const signals = this.strategyEngine.getTradeSignals(symbol);\n        \n        // Process buy signals\n        for (const buySignal of signals.buy) {\n          if (balance >= buySignal.buySize) {\n            // Simulate buy order\n            const quantity = buySignal.buySize / bar.close;\n            const commission = buySignal.buySize * this.config.binanceSettings.commissionRate;\n            \n            balance -= (buySignal.buySize + commission);\n            \n            // Record trade\n            const trade = {\n              time: bar.time,\n              type: 'BUY',\n              price: bar.close,\n              quantity,\n              value: buySignal.buySize,\n              commission,\n              gridLevel: buySignal.price\n            };\n            \n            result.trades.push(trade);\n            result.totalTrades++;\n          }\n        }\n        \n        // Process sell signals\n        for (const sellSignal of signals.sell) {\n          // Simulate sell order\n          const sellValue = sellSignal.sellSize * bar.close;\n          const commission = sellValue * this.config.binanceSettings.commissionRate;\n          const profit = sellValue - sellSignal.buySize - commission;\n          \n          balance += sellValue - commission;\n          \n          // Update highest balance and drawdown\n          if (balance > highestBalance) {\n            highestBalance = balance;\n            currentDrawdown = 0;\n          } else {\n            currentDrawdown = (highestBalance - balance) / highestBalance;\n            if (currentDrawdown > maxDrawdown) {\n              maxDrawdown = currentDrawdown;\n            }\n          }\n          \n          // Record trade\n          const trade = {\n            time: bar.time,\n            type: 'SELL',\n            price: bar.close,\n            quantity: sellSignal.sellSize / bar.close,\n            value: sellValue,\n            commission,\n            profit,\n            gridLevel: sellSignal.price\n          };\n          \n          result.trades.push(trade);\n          result.totalTrades++;\n          \n          if (profit > 0) {\n            result.winningTrades++;\n          } else {\n            result.losingTrades++;\n          }\n          \n          result.totalProfit += profit;\n        }\n      }\n      \n      // Calculate final results\n      result.finalBalance = balance;\n      result.totalProfitPercentage = (result.totalProfit / result.initialBalance) * 100;\n      result.winRate = result.totalTrades > 0 ? (result.winningTrades / result.totalTrades) * 100 : 0;\n      result.maxDrawdown = maxDrawdown * 100;\n      \n      results.set(symbol, result);\n      \n      // Generate report\n      await this.reportService.saveBacktestReport(result);\n      \n      console.log(`Backtest completed for ${symbol}`);\n      console.log(`Total profit: ${result.totalProfit} ${this.config.maxBudget.currency} (${result.totalProfitPercentage.toFixed(2)}%)`);\n      console.log(`Win rate: ${result.winRate.toFixed(2)}%`);\n      console.log(`Max drawdown: ${result.maxDrawdown.toFixed(2)}%`);\n    }\n    \n    return results;\n  }\n}\n```",
        "testStrategy": "1. Test with different historical data periods to verify consistency\n2. Verify correct calculation of performance metrics (profit/loss, drawdown, win rate)\n3. Test with edge cases (extreme volatility, flat markets)\n4. Compare backtest results with manual calculations for a small sample\n5. Test report generation functionality\n6. Verify handling of different configuration parameters",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Paper Trading Module Implementation",
        "description": "Develop the paper trading module that simulates real-time trading with virtual funds using live market data.",
        "details": "1. Create a PaperTrader class that simulates trading with virtual funds\n2. Implement real-time data streaming from Binance WebSocket API\n3. Simulate order execution with realistic conditions (slippage, partial fills)\n4. Track virtual balances and positions\n5. Generate real-time logs and periodic reports\n\nExample implementation:\n```typescript\nimport { BotConfig } from '../config/ConfigLoader';\nimport { BinanceService } from '../services/BinanceService';\nimport { StrategyEngine } from '../services/StrategyEngine';\nimport { NotificationService } from '../services/NotificationService';\nimport { ReportService } from '../services/ReportService';\n\ninterface VirtualBalance {\n  [currency: string]: number;\n}\n\ninterface VirtualOrder {\n  id: string;\n  symbol: string;\n  side: 'BUY' | 'SELL';\n  type: 'LIMIT' | 'MARKET';\n  price: number;\n  quantity: number;\n  status: 'NEW' | 'PARTIALLY_FILLED' | 'FILLED' | 'CANCELED';\n  filledQuantity: number;\n  createTime: number;\n  updateTime: number;\n}\n\nexport class PaperTrader {\n  private config: BotConfig;\n  private binanceService: BinanceService;\n  private strategyEngine: StrategyEngine;\n  private notificationService: NotificationService;\n  private reportService: ReportService;\n  \n  private virtualBalances: VirtualBalance = {};\n  private virtualOrders: Map<string, VirtualOrder> = new Map();\n  private lastOrderId = 0;\n  \n  private isRunning = false;\n  private marketDataSubscriptions: Map<string, any> = new Map();\n\n  constructor(\n    config: BotConfig,\n    binanceService: BinanceService,\n    strategyEngine: StrategyEngine,\n    notificationService: NotificationService,\n    reportService: ReportService\n  ) {\n    this.config = config;\n    this.binanceService = binanceService;\n    this.strategyEngine = strategyEngine;\n    this.notificationService = notificationService;\n    this.reportService = reportService;\n    \n    // Initialize virtual balances\n    this.virtualBalances[this.config.maxBudget.currency] = this.config.maxBudget.amount;\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    console.log('Starting paper trading mode...');\n    this.notificationService.sendNotification('Paper trading started');\n    \n    // Initialize strategy for each symbol\n    for (const symbolConfig of this.config.symbols) {\n      const symbol = symbolConfig.pair;\n      console.log(`Initializing strategy for ${symbol}...`);\n      \n      // Fetch historical data for initial calculations\n      const endTime = Date.now();\n      const startTime = endTime - (500 * 60 * 1000); // 500 minutes of 1m candles\n      const historicalData = await this.binanceService.getHistoricalKlines(symbol, '1m', startTime, endTime);\n      \n      // Initialize strategy\n      this.strategyEngine.initializeStrategy(symbol, historicalData);\n      \n      // Subscribe to real-time market data\n      this.subscribeToMarketData(symbol);\n    }\n    \n    // Start periodic reporting\n    this.startPeriodicReporting();\n  }\n\n  stop(): void {\n    if (!this.isRunning) return;\n    \n    this.isRunning = false;\n    console.log('Stopping paper trading mode...');\n    \n    // Unsubscribe from all market data\n    this.marketDataSubscriptions.forEach((_, symbol) => {\n      this.binanceService.unsubscribeFromKlineUpdates(symbol, '1m');\n    });\n    this.marketDataSubscriptions.clear();\n    \n    // Generate final report\n    this.generateFinalReport();\n    \n    this.notificationService.sendNotification('Paper trading stopped');\n  }\n\n  private subscribeToMarketData(symbol: string): void {\n    console.log(`Subscribing to real-time data for ${symbol}...`);\n    \n    this.binanceService.subscribeToKlineUpdates(symbol, '1m', (kline) => {\n      if (!this.isRunning) return;\n      \n      // Process only completed candles\n      if (kline.isFinal) {\n        this.processKline(symbol, kline);\n      }\n    });\n    \n    this.marketDataSubscriptions.set(symbol, true);\n  }\n\n  private processKline(symbol: string, kline: any): void {\n    // Update strategy state\n    this.strategyEngine.updateState(symbol, {\n      time: kline.startTime,\n      open: parseFloat(kline.open),\n      high: parseFloat(kline.high),\n      low: parseFloat(kline.low),\n      close: parseFloat(kline.close),\n      volume: parseFloat(kline.volume)\n    });\n    \n    // Process virtual orders\n    this.processVirtualOrders(symbol, kline);\n    \n    // Get new trade signals\n    const signals = this.strategyEngine.getTradeSignals(symbol);\n    \n    // Create virtual orders for buy signals\n    for (const buySignal of signals.buy) {\n      this.createVirtualOrder({\n        symbol,\n        side: 'BUY',\n        type: 'LIMIT',\n        price: buySignal.price,\n        quantity: buySignal.buySize / buySignal.price\n      });\n    }\n    \n    // Create virtual orders for sell signals\n    for (const sellSignal of signals.sell) {\n      this.createVirtualOrder({\n        symbol,\n        side: 'SELL',\n        type: 'LIMIT',\n        price: sellSignal.price,\n        quantity: sellSignal.sellSize / sellSignal.price\n      });\n    }\n  }\n\n  private createVirtualOrder(params: {\n    symbol: string;\n    side: 'BUY' | 'SELL';\n    type: 'LIMIT' | 'MARKET';\n    price: number;\n    quantity: number;\n  }): string {\n    const { symbol, side, type, price, quantity } = params;\n    \n    // Check if we have enough balance\n    const [baseCurrency, quoteCurrency] = symbol.split('/');\n    \n    if (side === 'BUY') {\n      const requiredBalance = price * quantity * (1 + this.config.binanceSettings.commissionRate);\n      if (!this.virtualBalances[quoteCurrency] || this.virtualBalances[quoteCurrency] < requiredBalance) {\n        console.log(`Insufficient ${quoteCurrency} balance for BUY order`);\n        return null;\n      }\n    } else {\n      if (!this.virtualBalances[baseCurrency] || this.virtualBalances[baseCurrency] < quantity) {\n        console.log(`Insufficient ${baseCurrency} balance for SELL order`);\n        return null;\n      }\n    }\n    \n    // Create virtual order\n    const orderId = (++this.lastOrderId).toString();\n    const now = Date.now();\n    \n    const order: VirtualOrder = {\n      id: orderId,\n      symbol,\n      side,\n      type,\n      price,\n      quantity,\n      status: 'NEW',\n      filledQuantity: 0,\n      createTime: now,\n      updateTime: now\n    };\n    \n    this.virtualOrders.set(orderId, order);\n    \n    // Log order creation\n    console.log(`Created virtual ${side} order: ${quantity} ${baseCurrency} @ ${price} ${quoteCurrency}`);\n    this.reportService.logTransaction({\n      time: now,\n      type: 'ORDER_CREATED',\n      symbol,\n      side,\n      price,\n      quantity,\n      orderId\n    });\n    \n    // Send notification\n    this.notificationService.sendNotification(\n      `Paper Trade: Created ${side} order for ${quantity} ${baseCurrency} @ ${price} ${quoteCurrency}`\n    );\n    \n    return orderId;\n  }\n\n  private processVirtualOrders(symbol: string, kline: any): void {\n    const [baseCurrency, quoteCurrency] = symbol.split('/');\n    const low = parseFloat(kline.low);\n    const high = parseFloat(kline.high);\n    \n    // Process each virtual order\n    this.virtualOrders.forEach((order, orderId) => {\n      if (order.symbol !== symbol || order.status !== 'NEW') return;\n      \n      // Check if order should be filled\n      if (\n        (order.side === 'BUY' && low <= order.price) ||\n        (order.side === 'SELL' && high >= order.price)\n      ) {\n        // Fill the order\n        order.status = 'FILLED';\n        order.filledQuantity = order.quantity;\n        order.updateTime = Date.now();\n        \n        // Update virtual balances\n        if (order.side === 'BUY') {\n          // Deduct quote currency (e.g., USDT)\n          const cost = order.price * order.quantity;\n          const commission = cost * this.config.binanceSettings.commissionRate;\n          this.virtualBalances[quoteCurrency] -= (cost + commission);\n          \n          // Add base currency (e.g., BTC)\n          if (!this.virtualBalances[baseCurrency]) {\n            this.virtualBalances[baseCurrency] = 0;\n          }\n          this.virtualBalances[baseCurrency] += order.quantity;\n        } else {\n          // Deduct base currency\n          this.virtualBalances[baseCurrency] -= order.quantity;\n          \n          // Add quote currency\n          const proceeds = order.price * order.quantity;\n          const commission = proceeds * this.config.binanceSettings.commissionRate;\n          if (!this.virtualBalances[quoteCurrency]) {\n            this.virtualBalances[quoteCurrency] = 0;\n          }\n          this.virtualBalances[quoteCurrency] += (proceeds - commission);\n        }\n        \n        // Log order fill\n        console.log(`Filled virtual ${order.side} order: ${order.quantity} ${baseCurrency} @ ${order.price} ${quoteCurrency}`);\n        this.reportService.logTransaction({\n          time: order.updateTime,\n          type: 'ORDER_FILLED',\n          symbol,\n          side: order.side,\n          price: order.price,\n          quantity: order.quantity,\n          orderId\n        });\n        \n        // Send notification\n        this.notificationService.sendNotification(\n          `Paper Trade: Filled ${order.side} order for ${order.quantity} ${baseCurrency} @ ${order.price} ${quoteCurrency}`\n        );\n      }\n    });\n  }\n\n  private startPeriodicReporting(): void {\n    // Report status every hour\n    setInterval(() => {\n      if (!this.isRunning) return;\n      \n      this.generateStatusReport();\n    }, 60 * 60 * 1000); // 1 hour\n  }\n\n  private generateStatusReport(): void {\n    const report = {\n      time: Date.now(),\n      virtualBalances: this.virtualBalances,\n      openOrders: Array.from(this.virtualOrders.values())\n        .filter(order => order.status === 'NEW')\n    };\n    \n    // Log to file\n    this.reportService.saveStatusReport(report, 'papertrade');\n    \n    // Send notification\n    this.notificationService.sendNotification(\n      `Paper Trade Status: ${Object.entries(this.virtualBalances)\n        .map(([currency, balance]) => `${balance.toFixed(8)} ${currency}`)\n        .join(', ')}`\n    );\n  }\n\n  private generateFinalReport(): void {\n    const report = {\n      endTime: Date.now(),\n      duration: this.isRunning ? 'ongoing' : `${(Date.now() - this.startTime) / (60 * 60 * 1000)} hours`,\n      finalBalances: this.virtualBalances,\n      profitLoss: {}\n    };\n    \n    // Calculate profit/loss for each currency\n    Object.entries(this.virtualBalances).forEach(([currency, balance]) => {\n      if (currency === this.config.maxBudget.currency) {\n        report.profitLoss[currency] = balance - this.config.maxBudget.amount;\n      } else {\n        report.profitLoss[currency] = balance;\n      }\n    });\n    \n    // Save report\n    this.reportService.saveFinalReport(report, 'papertrade');\n    \n    // Send notification\n    this.notificationService.sendNotification(\n      `Paper Trading Completed\\n${Object.entries(report.profitLoss)\n        .map(([currency, profit]) => `${profit > 0 ? '+' : ''}${profit.toFixed(8)} ${currency}`)\n        .join('\\n')}`\n    );\n  }\n}\n```",
        "testStrategy": "1. Test with real-time market data from Binance WebSocket API\n2. Verify correct virtual order execution based on price movements\n3. Test virtual balance management and commission calculations\n4. Verify periodic and final reporting functionality\n5. Test handling of edge cases (network disconnections, API errors)\n6. Verify notification system integration",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Live Trading Module Implementation",
        "description": "Develop the live trading module that executes real trades on Binance Spot using the grid strategy.",
        "details": "1. Create a LiveTrader class that executes real trades on Binance\n2. Implement real-time order management with Binance API\n3. Add risk management features and safety checks\n4. Implement error handling and recovery mechanisms\n5. Create detailed logging and reporting for live trades\n\nExample implementation:\n```typescript\nimport { BotConfig } from '../config/ConfigLoader';\nimport { BinanceService } from '../services/BinanceService';\nimport { StrategyEngine } from '../services/StrategyEngine';\nimport { NotificationService } from '../services/NotificationService';\nimport { ReportService } from '../services/ReportService';\n\nexport class LiveTrader {\n  private config: BotConfig;\n  private binanceService: BinanceService;\n  private strategyEngine: StrategyEngine;\n  private notificationService: NotificationService;\n  private reportService: ReportService;\n  \n  private isRunning = false;\n  private marketDataSubscriptions: Map<string, any> = new Map();\n  private activeOrders: Map<string, any> = new Map();\n  private startTime: number;\n\n  constructor(\n    config: BotConfig,\n    binanceService: BinanceService,\n    strategyEngine: StrategyEngine,\n    notificationService: NotificationService,\n    reportService: ReportService\n  ) {\n    this.config = config;\n    this.binanceService = binanceService;\n    this.strategyEngine = strategyEngine;\n    this.notificationService = notificationService;\n    this.reportService = reportService;\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) return;\n    \n    // Confirm with user before starting live trading\n    console.log('WARNING: You are about to start LIVE trading with real funds.');\n    console.log('Press Ctrl+C within 10 seconds to cancel.');\n    \n    await new Promise(resolve => setTimeout(resolve, 10000));\n    \n    this.isRunning = true;\n    this.startTime = Date.now();\n    console.log('Starting live trading mode...');\n    this.notificationService.sendNotification('⚠️ LIVE trading started ⚠️');\n    \n    // Check account balances\n    await this.checkAccountBalances();\n    \n    // Initialize strategy for each symbol\n    for (const symbolConfig of this.config.symbols) {\n      const symbol = symbolConfig.pair;\n      console.log(`Initializing strategy for ${symbol}...`);\n      \n      // Fetch historical data for initial calculations\n      const endTime = Date.now();\n      const startTime = endTime - (500 * 60 * 1000); // 500 minutes of 1m candles\n      const historicalData = await this.binanceService.getHistoricalKlines(symbol, '1m', startTime, endTime);\n      \n      // Initialize strategy\n      this.strategyEngine.initializeStrategy(symbol, historicalData);\n      \n      // Subscribe to real-time market data\n      this.subscribeToMarketData(symbol);\n      \n      // Subscribe to order updates\n      this.subscribeToOrderUpdates(symbol);\n    }\n    \n    // Start periodic reporting\n    this.startPeriodicReporting();\n    \n    // Start order monitoring\n    this.startOrderMonitoring();\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) return;\n    \n    this.isRunning = false;\n    console.log('Stopping live trading mode...');\n    \n    // Cancel all open orders\n    await this.cancelAllOrders();\n    \n    // Unsubscribe from all market data\n    this.marketDataSubscriptions.forEach((_, symbol) => {\n      this.binanceService.unsubscribeFromKlineUpdates(symbol, '1m');\n    });\n    this.marketDataSubscriptions.clear();\n    \n    // Generate final report\n    await this.generateFinalReport();\n    \n    this.notificationService.sendNotification('LIVE trading stopped');\n  }\n\n  private async checkAccountBalances(): Promise<void> {\n    try {\n      const balances = await this.binanceService.getAccountBalance();\n      \n      console.log('Account balances:');\n      Object.entries(balances).forEach(([currency, balance]) => {\n        if (balance.available > 0 || balance.onOrder > 0) {\n          console.log(`${currency}: ${balance.available} (available) + ${balance.onOrder} (in orders)`);\n        }\n      });\n      \n      // Check if we have enough balance for trading\n      const budgetCurrency = this.config.maxBudget.currency;\n      const availableBalance = balances[budgetCurrency]?.available || 0;\n      \n      if (availableBalance < this.config.maxBudget.amount * 0.1) {\n        const message = `WARNING: Available ${budgetCurrency} balance (${availableBalance}) is less than 10% of configured budget (${this.config.maxBudget.amount})!`;\n        console.warn(message);\n        this.notificationService.sendNotification(message);\n      }\n    } catch (error) {\n      console.error('Error checking account balances:', error);\n      this.notificationService.sendNotification('Error checking account balances: ' + error.message);\n    }\n  }\n\n  private subscribeToMarketData(symbol: string): void {\n    console.log(`Subscribing to real-time data for ${symbol}...`);\n    \n    this.binanceService.subscribeToKlineUpdates(symbol, '1m', (kline) => {\n      if (!this.isRunning) return;\n      \n      // Process only completed candles\n      if (kline.isFinal) {\n        this.processKline(symbol, kline);\n      }\n    });\n    \n    this.marketDataSubscriptions.set(symbol, true);\n  }\n\n  private subscribeToOrderUpdates(symbol: string): void {\n    console.log(`Subscribing to order updates for ${symbol}...`);\n    \n    this.binanceService.subscribeToUserDataUpdates((data) => {\n      if (!this.isRunning) return;\n      \n      if (data.eventType === 'executionReport' && data.symbol === symbol.replace('/', '')) {\n        this.processOrderUpdate(data);\n      }\n    });\n  }\n\n  private processKline(symbol: string, kline: any): void {\n    // Update strategy state\n    this.strategyEngine.updateState(symbol, {\n      time: kline.startTime,\n      open: parseFloat(kline.open),\n      high: parseFloat(kline.high),\n      low: parseFloat(kline.low),\n      close: parseFloat(kline.close),\n      volume: parseFloat(kline.volume)\n    });\n    \n    // Get new trade signals\n    const signals = this.strategyEngine.getTradeSignals(symbol);\n    \n    // Execute buy signals\n    for (const buySignal of signals.buy) {\n      this.executeBuyOrder(symbol, buySignal);\n    }\n    \n    // Execute sell signals\n    for (const sellSignal of signals.sell) {\n      this.executeSellOrder(symbol, sellSignal);\n    }\n  }\n\n  private async executeBuyOrder(symbol: string, signal: any): Promise<void> {\n    try {\n      // Check if we already have an active order at this price level\n      const existingOrders = Array.from(this.activeOrders.values())\n        .filter(order => \n          order.symbol === symbol && \n          order.side === 'BUY' && \n          Math.abs(order.price - signal.price) < 0.0001\n        );\n      \n      if (existingOrders.length > 0) {\n        console.log(`Already have a BUY order at price level ${signal.price} for ${symbol}`);\n        return;\n      }\n      \n      // Calculate quantity based on budget\n      const quantity = signal.buySize / signal.price;\n      \n      // Place order on Binance\n      const order = await this.binanceService.createOrder(symbol, 'BUY', 'LIMIT', quantity, signal.price);\n      \n      // Store order in active orders\n      this.activeOrders.set(order.orderId, {\n        ...order,\n        gridLevel: signal.price\n      });\n      \n      // Log order creation\n      console.log(`Created BUY order: ${quantity} ${symbol} @ ${signal.price}`);\n      this.reportService.logTransaction({\n        time: Date.now(),\n        type: 'ORDER_CREATED',\n        symbol,\n        side: 'BUY',\n        price: signal.price,\n        quantity,\n        orderId: order.orderId\n      });\n      \n      // Send notification\n      this.notificationService.sendNotification(\n        `LIVE Trade: Created BUY order for ${quantity} ${symbol} @ ${signal.price}`\n      );\n    } catch (error) {\n      console.error(`Error executing BUY order for ${symbol}:`, error);\n      this.notificationService.sendNotification(\n        `Error executing BUY order for ${symbol}: ${error.message}`\n      );\n    }\n  }\n\n  private async executeSellOrder(symbol: string, signal: any): Promise<void> {\n    try {\n      // Check if we already have an active order at this price level\n      const existingOrders = Array.from(this.activeOrders.values())\n        .filter(order => \n          order.symbol === symbol && \n          order.side === 'SELL' && \n          Math.abs(order.price - signal.price) < 0.0001\n        );\n      \n      if (existingOrders.length > 0) {\n        console.log(`Already have a SELL order at price level ${signal.price} for ${symbol}`);\n        return;\n      }\n      \n      // Calculate quantity\n      const quantity = signal.sellSize / signal.price;\n      \n      // Place order on Binance\n      const order = await this.binanceService.createOrder(symbol, 'SELL', 'LIMIT', quantity, signal.price);\n      \n      // Store order in active orders\n      this.activeOrders.set(order.orderId, {\n        ...order,\n        gridLevel: signal.price\n      });\n      \n      // Log order creation\n      console.log(`Created SELL order: ${quantity} ${symbol} @ ${signal.price}`);\n      this.reportService.logTransaction({\n        time: Date.now(),\n        type: 'ORDER_CREATED',\n        symbol,\n        side: 'SELL',\n        price: signal.price,\n        quantity,\n        orderId: order.orderId\n      });\n      \n      // Send notification\n      this.notificationService.sendNotification(\n        `LIVE Trade: Created SELL order for ${quantity} ${symbol} @ ${signal.price}`\n      );\n    } catch (error) {\n      console.error(`Error executing SELL order for ${symbol}:`, error);\n      this.notificationService.sendNotification(\n        `Error executing SELL order for ${symbol}: ${error.message}`\n      );\n    }\n  }\n\n  private processOrderUpdate(data: any): void {\n    const orderId = data.orderId;\n    const order = this.activeOrders.get(orderId);\n    \n    if (!order) return;\n    \n    // Update order status\n    order.status = data.orderStatus;\n    order.filledQuantity = data.accumulatedQuantity;\n    order.updateTime = Date.now();\n    \n    // Log order update\n    console.log(`Order ${orderId} updated: ${order.status}`);\n    this.reportService.logTransaction({\n      time: Date.now(),\n      type: 'ORDER_UPDATED',\n      orderId,\n      status: order.status,\n      filledQuantity: order.filledQuantity\n    });\n    \n    // If order is filled, remove from active orders\n    if (order.status === 'FILLED') {\n      this.activeOrders.delete(orderId);\n      \n      // Log order fill\n      console.log(`Order ${orderId} filled: ${order.quantity} ${order.symbol} @ ${order.price}`);\n      this.reportService.logTransaction({\n        time: Date.now(),\n        type: 'ORDER_FILLED',\n        orderId,\n        symbol: order.symbol,\n        side: order.side,\n        price: order.price,\n        quantity: order.quantity\n      });\n      \n      // Send notification\n      this.notificationService.sendNotification(\n        `LIVE Trade: Filled ${order.side} order for ${order.quantity} ${order.symbol} @ ${order.price}`\n      );\n    }\n  }\n\n  private startOrderMonitoring(): void {\n    // Check order status every minute\n    setInterval(async () => {\n      if (!this.isRunning) return;\n      \n      try {\n        // Get all open orders from Binance\n        const openOrders = await this.binanceService.getOpenOrders();\n        \n        // Update active orders\n        this.activeOrders.forEach(async (order, orderId) => {\n          const binanceOrder = openOrders.find(o => o.orderId === orderId);\n          \n          if (!binanceOrder) {\n            // Order not found in open orders, check if it was filled\n            try {\n              const orderStatus = await this.binanceService.getOrder(order.symbol, orderId);\n              \n              if (orderStatus.status === 'FILLED') {\n                // Order was filled\n                this.processOrderUpdate({\n                  eventType: 'executionReport',\n                  orderId,\n                  orderStatus: 'FILLED',\n                  accumulatedQuantity: orderStatus.executedQty,\n                  symbol: order.symbol\n                });\n              } else if (orderStatus.status === 'CANCELED') {\n                // Order was canceled\n                this.activeOrders.delete(orderId);\n              }\n            } catch (error) {\n              console.error(`Error checking order ${orderId} status:`, error);\n            }\n          }\n        });\n      } catch (error) {\n        console.error('Error monitoring orders:', error);\n      }\n    }, 60 * 1000); // 1 minute\n  }\n\n  private async cancelAllOrders(): Promise<void> {\n    console.log('Canceling all open orders...');\n    \n    try {\n      // Get all symbols we're trading\n      const symbols = this.config.symbols.map(s => s.pair);\n      \n      // Cancel orders for each symbol\n      for (const symbol of symbols) {\n        try {\n          await this.binanceService.cancelAllOrders(symbol);\n          console.log(`Canceled all orders for ${symbol}`);\n        } catch (error) {\n          console.error(`Error canceling orders for ${symbol}:`, error);\n        }\n      }\n      \n      // Clear active orders\n      this.activeOrders.clear();\n      \n      console.log('All orders canceled');\n    } catch (error) {\n      console.error('Error canceling all orders:', error);\n      this.notificationService.sendNotification('Error canceling all orders: ' + error.message);\n    }\n  }\n\n  private startPeriodicReporting(): void {\n    // Report status every hour\n    setInterval(async () => {\n      if (!this.isRunning) return;\n      \n      await this.generateStatusReport();\n    }, 60 * 60 * 1000); // 1 hour\n  }\n\n  private async generateStatusReport(): Promise<void> {\n    try {\n      // Get account balances\n      const balances = await this.binanceService.getAccountBalance();\n      \n      // Get open orders\n      const openOrders = await this.binanceService.getOpenOrders();\n      \n      const report = {\n        time: Date.now(),\n        balances: Object.entries(balances)\n          .filter(([_, balance]) => balance.available > 0 || balance.onOrder > 0)\n          .reduce((acc, [currency, balance]) => {\n            acc[currency] = balance;\n            return acc;\n          }, {}),\n        openOrders\n      };\n      \n      // Log to file\n      this.reportService.saveStatusReport(report, 'live');\n      \n      // Send notification\n      const balanceText = Object.entries(report.balances)\n        .map(([currency, balance]) => `${balance.available.toFixed(8)} ${currency} (+ ${balance.onOrder.toFixed(8)} in orders)`)\n        .join('\\n');\n      \n      this.notificationService.sendNotification(\n        `LIVE Trading Status\\n\\nBalances:\\n${balanceText}\\n\\nOpen Orders: ${openOrders.length}`\n      );\n    } catch (error) {\n      console.error('Error generating status report:', error);\n    }\n  }\n\n  private async generateFinalReport(): Promise<void> {\n    try {\n      // Get account balances\n      const balances = await this.binanceService.getAccountBalance();\n      \n      // Get trade history\n      const tradeHistory = await this.binanceService.getMyTrades();\n      \n      const report = {\n        startTime: this.startTime,\n        endTime: Date.now(),\n        duration: `${((Date.now() - this.startTime) / (60 * 60 * 1000)).toFixed(2)} hours`,\n        finalBalances: Object.entries(balances)\n          .filter(([_, balance]) => balance.available > 0 || balance.onOrder > 0)\n          .reduce((acc, [currency, balance]) => {\n            acc[currency] = balance;\n            return acc;\n          }, {}),\n        trades: tradeHistory\n      };\n      \n      // Save report\n      this.reportService.saveFinalReport(report, 'live');\n      \n      // Send notification\n      const balanceText = Object.entries(report.finalBalances)\n        .map(([currency, balance]) => `${balance.available.toFixed(8)} ${currency} (+ ${balance.onOrder.toFixed(8)} in orders)`)\n        .join('\\n');\n      \n      this.notificationService.sendNotification(\n        `LIVE Trading Completed\\n\\nDuration: ${report.duration}\\n\\nFinal Balances:\\n${balanceText}\\n\\nTotal Trades: ${tradeHistory.length}`\n      );\n    } catch (error) {\n      console.error('Error generating final report:', error);\n    }\n  }\n}\n```",
        "testStrategy": "1. Test with Binance testnet before deploying to mainnet\n2. Verify correct order creation and management\n3. Test error handling for various API error scenarios\n4. Verify risk management features\n5. Test reporting and notification functionality\n6. Verify handling of network disconnections and API rate limits",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Notification Service Implementation",
        "description": "Develop a notification service that provides real-time updates via console output and Telegram messages.",
        "details": "1. Create a NotificationService class that handles all notifications\n2. Implement console logging with different severity levels\n3. Integrate with Telegram Bot API for sending messages\n4. Add support for different notification types and formatting\n\nExample implementation:\n```typescript\nimport TelegramBot from 'node-telegram-bot-api';\nimport { BotConfig } from '../config/ConfigLoader';\n\nenum LogLevel {\n  DEBUG = 'DEBUG',\n  INFO = 'INFO',\n  WARNING = 'WARNING',\n  ERROR = 'ERROR'\n}\n\nexport class NotificationService {\n  private config: BotConfig;\n  private telegramBot: TelegramBot | null = null;\n\n  constructor(config: BotConfig) {\n    this.config = config;\n    \n    // Initialize Telegram bot if enabled\n    if (\n      this.config.logging.enableTelegramOutput &&\n      this.config.apiKeys.telegramBotToken &&\n      this.config.apiKeys.telegramChatId\n    ) {\n      try {\n        this.telegramBot = new TelegramBot(this.config.apiKeys.telegramBotToken, { polling: false });\n        console.log('Telegram bot initialized');\n      } catch (error) {\n        console.error('Failed to initialize Telegram bot:', error);\n      }\n    }\n  }\n\n  log(message: string, level: LogLevel = LogLevel.INFO): void {\n    if (!this.config.logging.enableConsoleOutput) return;\n    \n    const timestamp = new Date().toISOString();\n    const formattedMessage = `[${timestamp}] [${level}] ${message}`;\n    \n    switch (level) {\n      case LogLevel.DEBUG:\n        console.debug(formattedMessage);\n        break;\n      case LogLevel.INFO:\n        console.info(formattedMessage);\n        break;\n      case LogLevel.WARNING:\n        console.warn(formattedMessage);\n        break;\n      case LogLevel.ERROR:\n        console.error(formattedMessage);\n        break;\n    }\n  }\n\n  async sendNotification(message: string, level: LogLevel = LogLevel.INFO): Promise<void> {\n    // Log to console\n    this.log(message, level);\n    \n    // Send to Telegram if enabled\n    if (\n      this.config.logging.enableTelegramOutput &&\n      this.telegramBot &&\n      this.config.apiKeys.telegramChatId\n    ) {\n      try {\n        // Format message for Telegram\n        let telegramMessage = message;\n        \n        // Add emoji based on log level\n        if (level === LogLevel.ERROR) {\n          telegramMessage = `🚨 ${telegramMessage}`;\n        } else if (level === LogLevel.WARNING) {\n          telegramMessage = `⚠️ ${telegramMessage}`;\n        } else if (level === LogLevel.INFO) {\n          telegramMessage = `ℹ️ ${telegramMessage}`;\n        }\n        \n        await this.telegramBot.sendMessage(\n          this.config.apiKeys.telegramChatId,\n          telegramMessage,\n          { parse_mode: 'Markdown' }\n        );\n      } catch (error) {\n        console.error('Failed to send Telegram notification:', error);\n      }\n    }\n  }\n\n  async sendTradeNotification(trade: {\n    symbol: string;\n    side: 'BUY' | 'SELL';\n    price: number;\n    quantity: number;\n    mode: 'backtest' | 'papertrade' | 'live';\n  }): Promise<void> {\n    const { symbol, side, price, quantity, mode } = trade;\n    \n    // Format message\n    let emoji = side === 'BUY' ? '🟢' : '🔴';\n    let modePrefix = '';\n    \n    if (mode === 'backtest') {\n      modePrefix = '[BACKTEST] ';\n    } else if (mode === 'papertrade') {\n      modePrefix = '[PAPER] ';\n    } else if (mode === 'live') {\n      modePrefix = '[LIVE] ';\n      emoji = side === 'BUY' ? '🟢🟢🟢' : '🔴🔴🔴'; // More emphasis for live trades\n    }\n    \n    const message = `${modePrefix}${emoji} ${side} ${quantity} ${symbol} @ ${price}`;\n    \n    // Send notification\n    await this.sendNotification(message);\n  }\n\n  async sendStatusNotification(status: {\n    mode: 'backtest' | 'papertrade' | 'live';\n    balances: { [currency: string]: number };\n    profit: number;\n    trades: number;\n  }): Promise<void> {\n    const { mode, balances, profit, trades } = status;\n    \n    // Format message\n    let modePrefix = '';\n    \n    if (mode === 'backtest') {\n      modePrefix = '[BACKTEST] ';\n    } else if (mode === 'papertrade') {\n      modePrefix = '[PAPER] ';\n    } else if (mode === 'live') {\n      modePrefix = '[LIVE] ';\n    }\n    \n    const profitEmoji = profit >= 0 ? '📈' : '📉';\n    const balanceText = Object.entries(balances)\n      .map(([currency, balance]) => `${balance.toFixed(8)} ${currency}`)\n      .join(', ');\n    \n    const message = `${modePrefix}Status Update\\n\\n${profitEmoji} Profit: ${profit.toFixed(8)} ${this.config.maxBudget.currency}\\n💰 Balances: ${balanceText}\\n🔄 Trades: ${trades}`;\n    \n    // Send notification\n    await this.sendNotification(message);\n  }\n\n  async sendErrorNotification(error: Error, context: string): Promise<void> {\n    const message = `Error in ${context}: ${error.message}`;\n    await this.sendNotification(message, LogLevel.ERROR);\n  }\n}\n```\n<info added on 2025-07-15T09:35:12.647Z>\n## Implementation Status\n\nThe NotificationService implementation has been successfully completed with the following enhancements and optimizations:\n\n### ✅ Completed Features:\n1. **Enhanced NotificationService** - Fully implemented with comprehensive functionality\n2. **Type Safety** - Strict TypeScript with Zod validation\n3. **Multiple Notification Channels** - Console, File logging, and Telegram integration\n4. **Advanced Methods** - Added enhanced methods aligned with task requirements:\n   - `sendTradeNotification(trade)` - Structured trade notifications\n   - `sendStatusNotification(status)` - Overloaded for both string and structured status\n   - `log(message, level)` - Direct logging with DEBUG/INFO/WARNING/ERROR levels\n   - `sendPerformanceNotification(metrics)` - System performance monitoring\n\n### 📊 Test Coverage Achieved:\n- **97.33% Statement Coverage** (Exceeds 80% requirement)\n- **92.75% Branch Coverage** (Exceeds 80% requirement) \n- **100% Function Coverage** (Perfect score)\n- **39 Comprehensive Tests** covering all functionality including edge cases\n\n### 🏗️ Architecture Improvements:\n1. **Error Handling** - Robust error handling with retry mechanisms for Telegram\n2. **Performance** - Efficient async/await patterns and concurrent notification sending\n3. **Configurability** - Environment variable support and flexible configuration\n4. **Resource Management** - Proper cleanup and resource disposal\n\n### 📚 Documentation:\n- **Complete Usage Guide** - Comprehensive documentation with examples\n- **API Reference** - Detailed method descriptions and parameter explanations\n- **Integration Examples** - Real-world usage patterns and best practices\n- **Error Recovery** - Detailed error handling strategies\n\n### 🔧 Technical Compliance:\n- ✅ TypeScript strict mode enabled\n- ✅ Zod validation for all configurations\n- ✅ ESLint/Prettier formatting applied\n- ✅ Comprehensive JSDoc comments\n- ✅ SOLID principles followed\n- ✅ Clean code practices implemented\n- ✅ Performance optimizations applied\n\n### 📁 File Structure:\n```\nsrc/services/NotificationService.ts     - Main implementation\nsrc/__tests__/services/NotificationService.test.ts - Comprehensive tests\ndocs/NotificationService-Usage.md      - Complete documentation\n```\n</info added on 2025-07-15T09:35:12.647Z>",
        "testStrategy": "1. Test console output with different log levels\n2. Test Telegram integration with mock API\n3. Verify message formatting for different notification types\n4. Test error handling when Telegram API is unavailable\n5. Verify configuration options (enable/disable console/Telegram)\n6. Test with different message content types (text, numbers, special characters)",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Reporting Service Implementation",
        "description": "Develop a reporting service that generates and saves detailed transaction logs and performance reports.",
        "details": "1. Create a ReportService class that handles all reporting functionality\n2. Implement methods for logging transactions to files\n3. Create methods for generating and saving performance reports\n4. Add support for different file formats (JSON, CSV, TXT)\n\nExample implementation:\n```typescript\nimport fs from 'fs';\nimport path from 'path';\nimport { BotConfig } from '../config/ConfigLoader';\n\nexport class ReportService {\n  private config: BotConfig;\n  private reportDirectory: string;\n  private transactionLogPath: string;\n\n  constructor(config: BotConfig) {\n    this.config = config;\n    this.reportDirectory = config.logging.reportDirectory;\n    \n    // Create report directory if it doesn't exist\n    if (!fs.existsSync(this.reportDirectory)) {\n      fs.mkdirSync(this.reportDirectory, { recursive: true });\n    }\n    \n    // Set transaction log path\n    this.transactionLogPath = path.join(\n      this.reportDirectory,\n      config.logging.transactionLogFileName\n    );\n  }\n\n  logTransaction(transaction: any): void {\n    try {\n      // Add timestamp if not present\n      if (!transaction.time) {\n        transaction.time = Date.now();\n      }\n      \n      // Convert to JSON line\n      const line = JSON.stringify(transaction) + '\\n';\n      \n      // Append to transaction log file\n      fs.appendFileSync(this.transactionLogPath, line);\n    } catch (error) {\n      console.error('Error logging transaction:', error);\n    }\n  }\n\n  saveBacktestReport(result: any): void {\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const fileName = `backtest_report_${result.symbol.replace('/', '')}_${timestamp}.json`;\n      const filePath = path.join(this.reportDirectory, fileName);\n      \n      // Save as JSON\n      fs.writeFileSync(filePath, JSON.stringify(result, null, 2));\n      console.log(`Backtest report saved to ${filePath}`);\n      \n      // Save trades as CSV\n      if (result.trades && result.trades.length > 0) {\n        const csvFileName = `backtest_trades_${result.symbol.replace('/', '')}_${timestamp}.csv`;\n        const csvFilePath = path.join(this.reportDirectory, csvFileName);\n        \n        // Create CSV header\n        const headers = Object.keys(result.trades[0]).join(',');\n        \n        // Create CSV rows\n        const rows = result.trades.map(trade => \n          Object.values(trade).map(value => \n            typeof value === 'string' ? `\"${value}\"` : value\n          ).join(',')\n        );\n        \n        // Write CSV file\n        fs.writeFileSync(csvFilePath, [headers, ...rows].join('\\n'));\n        console.log(`Backtest trades saved to ${csvFilePath}`);\n      }\n    } catch (error) {\n      console.error('Error saving backtest report:', error);\n    }\n  }\n\n  saveStatusReport(report: any, mode: 'papertrade' | 'live'): void {\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const fileName = `${mode}_status_${timestamp}.json`;\n      const filePath = path.join(this.reportDirectory, fileName);\n      \n      // Save as JSON\n      fs.writeFileSync(filePath, JSON.stringify(report, null, 2));\n      console.log(`${mode.charAt(0).toUpperCase() + mode.slice(1)} status report saved to ${filePath}`);\n    } catch (error) {\n      console.error(`Error saving ${mode} status report:`, error);\n    }\n  }\n\n  saveFinalReport(report: any, mode: 'papertrade' | 'live'): void {\n    try {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const fileName = `${mode}_final_report_${timestamp}.json`;\n      const filePath = path.join(this.reportDirectory, fileName);\n      \n      // Save as JSON\n      fs.writeFileSync(filePath, JSON.stringify(report, null, 2));\n      console.log(`${mode.charAt(0).toUpperCase() + mode.slice(1)} final report saved to ${filePath}`);\n      \n      // Save summary as TXT\n      const txtFileName = `${mode}_summary_${timestamp}.txt`;\n      const txtFilePath = path.join(this.reportDirectory, txtFileName);\n      \n      // Create summary text\n      let summaryText = `${mode.toUpperCase()} TRADING SUMMARY\\n`;\n      summaryText += `=========================\\n\\n`;\n      summaryText += `Start Time: ${new Date(report.startTime).toISOString()}\\n`;\n      summaryText += `End Time: ${new Date(report.endTime).toISOString()}\\n`;\n      summaryText += `Duration: ${report.duration}\\n\\n`;\n      \n      summaryText += `FINAL BALANCES:\\n`;\n      Object.entries(report.finalBalances).forEach(([currency, balance]) => {\n        summaryText += `${currency}: ${JSON.stringify(balance)}\\n`;\n      });\n      \n      if (report.profitLoss) {\n        summaryText += `\\nPROFIT/LOSS:\\n`;\n        Object.entries(report.profitLoss).forEach(([currency, profit]) => {\n          summaryText += `${currency}: ${profit}\\n`;\n        });\n      }\n      \n      if (report.trades) {\n        summaryText += `\\nTOTAL TRADES: ${report.trades.length}\\n`;\n      }\n      \n      // Write TXT file\n      fs.writeFileSync(txtFilePath, summaryText);\n      console.log(`${mode.charAt(0).toUpperCase() + mode.slice(1)} summary saved to ${txtFilePath}`);\n    } catch (error) {\n      console.error(`Error saving ${mode} final report:`, error);\n    }\n  }\n\n  getTransactionLog(): any[] {\n    try {\n      if (!fs.existsSync(this.transactionLogPath)) {\n        return [];\n      }\n      \n      const content = fs.readFileSync(this.transactionLogPath, 'utf8');\n      const lines = content.split('\\n').filter(line => line.trim() !== '');\n      \n      return lines.map(line => JSON.parse(line));\n    } catch (error) {\n      console.error('Error reading transaction log:', error);\n      return [];\n    }\n  }\n\n  generatePerformanceReport(transactions: any[]): any {\n    // Filter completed trades\n    const completedTrades = transactions.filter(t => t.type === 'ORDER_FILLED');\n    \n    // Group by symbol\n    const tradesBySymbol = completedTrades.reduce((acc, trade) => {\n      if (!acc[trade.symbol]) {\n        acc[trade.symbol] = [];\n      }\n      acc[trade.symbol].push(trade);\n      return acc;\n    }, {});\n    \n    // Calculate performance metrics for each symbol\n    const performanceBySymbol = {};\n    \n    Object.entries(tradesBySymbol).forEach(([symbol, trades]) => {\n      const buyTrades = trades.filter(t => t.side === 'BUY');\n      const sellTrades = trades.filter(t => t.side === 'SELL');\n      \n      const totalBuyVolume = buyTrades.reduce((sum, t) => sum + (t.price * t.quantity), 0);\n      const totalSellVolume = sellTrades.reduce((sum, t) => sum + (t.price * t.quantity), 0);\n      \n      const totalBuyCommission = buyTrades.reduce((sum, t) => sum + (t.commission || 0), 0);\n      const totalSellCommission = sellTrades.reduce((sum, t) => sum + (t.commission || 0), 0);\n      \n      const grossProfit = totalSellVolume - totalBuyVolume;\n      const totalCommission = totalBuyCommission + totalSellCommission;\n      const netProfit = grossProfit - totalCommission;\n      \n      performanceBySymbol[symbol] = {\n        totalTrades: trades.length,\n        buyTrades: buyTrades.length,\n        sellTrades: sellTrades.length,\n        totalBuyVolume,\n        totalSellVolume,\n        totalCommission,\n        grossProfit,\n        netProfit,\n        roi: totalBuyVolume > 0 ? (netProfit / totalBuyVolume) * 100 : 0\n      };\n    });\n    \n    // Calculate overall performance\n    const totalBuyVolume = Object.values(performanceBySymbol).reduce(\n      (sum: number, perf: any) => sum + perf.totalBuyVolume, 0\n    );\n    \n    const totalNetProfit = Object.values(performanceBySymbol).reduce(\n      (sum: number, perf: any) => sum + perf.netProfit, 0\n    );\n    \n    return {\n      timestamp: Date.now(),\n      overallPerformance: {\n        totalTrades: completedTrades.length,\n        totalBuyVolume,\n        totalNetProfit,\n        overallRoi: totalBuyVolume > 0 ? (totalNetProfit / totalBuyVolume) * 100 : 0\n      },\n      performanceBySymbol\n    };\n  }\n}\n```",
        "testStrategy": "1. Test transaction logging with various transaction types\n2. Verify report generation for backtest, papertrade, and live modes\n3. Test file writing and reading functionality\n4. Verify performance calculation accuracy\n5. Test handling of edge cases (empty transaction logs, missing data)\n6. Verify file format compatibility (JSON, CSV, TXT)",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Technical Indicators Implementation",
        "description": "Implement technical indicators required for the grid strategy, including ATR (Average True Range) and EMA (Exponential Moving Average).",
        "details": "1. Create a utility module for technical indicators\n2. Implement ATR calculation for grid interval determination\n3. Implement EMA calculation for trend filtering\n4. Add helper functions for price analysis and volatility measurement\n\nExample implementation:\n```typescript\nexport interface OHLCV {\n  time: number;\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n  volume: number;\n}\n\n/**\n * Calculate True Range for a single period\n */\nexport function calculateTR(current: OHLCV, previous: OHLCV | null): number {\n  if (!previous) {\n    return current.high - current.low; // First bar TR is simply High - Low\n  }\n  \n  // True Range is the greatest of:\n  // 1. Current High - Current Low\n  // 2. |Current High - Previous Close|\n  // 3. |Current Low - Previous Close|\n  const highLow = current.high - current.low;\n  const highPrevClose = Math.abs(current.high - previous.close);\n  const lowPrevClose = Math.abs(current.low - previous.close);\n  \n  return Math.max(highLow, highPrevClose, lowPrevClose);\n}\n\n/**\n * Calculate Average True Range (ATR)\n * @param data Array of OHLCV data\n * @param period ATR period (default: 14)\n * @returns ATR value\n */\nexport function calculateATR(data: OHLCV[], period: number = 14): number {\n  if (data.length < period + 1) {\n    throw new Error(`Not enough data for ATR calculation. Need at least ${period + 1} bars.`);\n  }\n  \n  // Calculate True Range for each period\n  const trValues: number[] = [];\n  \n  for (let i = 0; i < data.length; i++) {\n    const tr = calculateTR(data[i], i > 0 ? data[i - 1] : null);\n    trValues.push(tr);\n  }\n  \n  // For the first ATR, use simple average of TR values\n  let atr = trValues.slice(0, period).reduce((sum, tr) => sum + tr, 0) / period;\n  \n  // For subsequent ATRs, use the smoothing formula: ATR = ((Prior ATR * (period - 1)) + Current TR) / period\n  for (let i = period; i < trValues.length; i++) {\n    atr = ((atr * (period - 1)) + trValues[i]) / period;\n  }\n  \n  return atr;\n}\n\n/**\n * Calculate Exponential Moving Average (EMA)\n * @param data Array of OHLCV data\n * @param period EMA period\n * @param field Data field to use (default: 'close')\n * @returns EMA value\n */\nexport function calculateEMA(data: OHLCV[], period: number, field: keyof OHLCV = 'close'): number {\n  if (data.length < period) {\n    throw new Error(`Not enough data for EMA calculation. Need at least ${period} bars.`);\n  }\n  \n  // Calculate multiplier: 2 / (period + 1)\n  const multiplier = 2 / (period + 1);\n  \n  // Calculate SMA for the initial EMA value\n  const initialSMA = data.slice(0, period).reduce((sum, bar) => sum + bar[field], 0) / period;\n  \n  // Calculate EMA\n  let ema = initialSMA;\n  \n  for (let i = period; i < data.length; i++) {\n    ema = (data[i][field] - ema) * multiplier + ema;\n  }\n  \n  return ema;\n}\n\n/**\n * Calculate daily bar difference average\n * @param data Array of OHLCV data\n * @param barCount Number of bars to analyze\n * @returns Average bar difference\n */\nexport function calculateDailyBarDiffAverage(data: OHLCV[], barCount: number): number {\n  if (data.length < barCount) {\n    throw new Error(`Not enough data for bar difference calculation. Need at least ${barCount} bars.`);\n  }\n  \n  // Get the last N bars\n  const bars = data.slice(-barCount);\n  \n  // Calculate absolute difference between open and close for each bar\n  const diffs = bars.map(bar => Math.abs(bar.close - bar.open));\n  \n  // Calculate average difference\n  const avgDiff = diffs.reduce((sum, diff) => sum + diff, 0) / barCount;\n  \n  return avgDiff;\n}\n\n/**\n * Calculate percentage of volatile bars\n * @param data Array of OHLCV data\n * @param barCount Number of bars to analyze\n * @param volatilityThreshold Minimum percentage change to consider a bar volatile\n * @returns Ratio of volatile bars (0-1)\n */\nexport function calculateVolatileBarRatio(data: OHLCV[], barCount: number, volatilityThreshold: number): number {\n  if (data.length < barCount) {\n    throw new Error(`Not enough data for volatility calculation. Need at least ${barCount} bars.`);\n  }\n  \n  // Get the last N bars\n  const bars = data.slice(-barCount);\n  \n  // Count volatile bars\n  let volatileBarCount = 0;\n  \n  bars.forEach(bar => {\n    const percentChange = Math.abs(bar.close - bar.open) / bar.open;\n    if (percentChange > volatilityThreshold) {\n      volatileBarCount++;\n    }\n  });\n  \n  // Calculate ratio\n  return volatileBarCount / barCount;\n}\n\n/**\n * Check if price is within EMA deviation threshold\n * @param price Current price\n * @param ema EMA value\n * @param threshold Maximum allowed deviation as a percentage (0-1)\n * @returns Boolean indicating if price is within threshold\n */\nexport function isPriceWithinEmaThreshold(price: number, ema: number, threshold: number): boolean {\n  const deviation = Math.abs(price - ema) / ema;\n  return deviation <= threshold;\n}\n```",
        "testStrategy": "1. Write unit tests for each indicator function\n2. Test with known data sets and verify results against established sources\n3. Test edge cases (small data sets, extreme values)\n4. Verify calculation accuracy with different time periods\n5. Test performance with large data sets\n6. Verify compatibility with Binance data format",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Main Application and CLI Interface",
        "description": "Develop the main application entry point and command-line interface for starting and controlling the grid bot.",
        "details": "1. Create the main application class that orchestrates all components\n2. Implement command-line interface with options for different modes\n3. Add signal handling for graceful shutdown\n4. Implement application lifecycle management\n\nExample implementation:\n```typescript\nimport { Command } from 'commander';\nimport { ConfigLoader, BotConfig } from './config/ConfigLoader';\nimport { BinanceService } from './services/BinanceService';\nimport { StrategyEngine } from './services/StrategyEngine';\nimport { NotificationService } from './services/NotificationService';\nimport { ReportService } from './services/ReportService';\nimport { Backtester } from './modes/Backtester';\nimport { PaperTrader } from './modes/PaperTrader';\nimport { LiveTrader } from './modes/LiveTrader';\n\nclass GridBotApp {\n  private config: BotConfig;\n  private binanceService: BinanceService;\n  private strategyEngine: StrategyEngine;\n  private notificationService: NotificationService;\n  private reportService: ReportService;\n  \n  private backtester: Backtester | null = null;\n  private paperTrader: PaperTrader | null = null;\n  private liveTrader: LiveTrader | null = null;\n  \n  private isRunning = false;\n\n  constructor(configPath: string) {\n    // Load configuration\n    this.config = ConfigLoader.loadConfig(configPath);\n    \n    // Initialize services\n    this.binanceService = new BinanceService(this.config);\n    this.notificationService = new NotificationService(this.config);\n    this.reportService = new ReportService(this.config);\n    this.strategyEngine = new StrategyEngine(this.config);\n    \n    // Initialize trading modes\n    this.backtester = new Backtester(\n      this.config,\n      this.binanceService,\n      this.strategyEngine,\n      this.reportService\n    );\n    \n    this.paperTrader = new PaperTrader(\n      this.config,\n      this.binanceService,\n      this.strategyEngine,\n      this.notificationService,\n      this.reportService\n    );\n    \n    this.liveTrader = new LiveTrader(\n      this.config,\n      this.binanceService,\n      this.strategyEngine,\n      this.notificationService,\n      this.reportService\n    );\n    \n    // Set up signal handlers\n    this.setupSignalHandlers();\n  }\n\n  private setupSignalHandlers(): void {\n    // Handle graceful shutdown\n    process.on('SIGINT', async () => {\n      console.log('\\nReceived SIGINT. Shutting down...');\n      await this.stop();\n      process.exit(0);\n    });\n    \n    process.on('SIGTERM', async () => {\n      console.log('\\nReceived SIGTERM. Shutting down...');\n      await this.stop();\n      process.exit(0);\n    });\n    \n    // Handle uncaught exceptions\n    process.on('uncaughtException', async (error) => {\n      console.error('Uncaught exception:', error);\n      this.notificationService.sendNotification(\n        `Critical error: ${error.message}`,\n        'ERROR'\n      );\n      await this.stop();\n      process.exit(1);\n    });\n    \n    // Handle unhandled promise rejections\n    process.on('unhandledRejection', async (reason) => {\n      console.error('Unhandled promise rejection:', reason);\n      this.notificationService.sendNotification(\n        `Critical error: Unhandled promise rejection - ${reason}`,\n        'ERROR'\n      );\n      await this.stop();\n      process.exit(1);\n    });\n  }\n\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      console.log('Bot is already running');\n      return;\n    }\n    \n    this.isRunning = true;\n    console.log('Starting Binance Spot Grid Bot...');\n    \n    // Display configuration summary\n    console.log('Configuration:');\n    console.log(`- Trade Mode: ${this.config.tradeMode}`);\n    console.log(`- Exchange: ${this.config.exchange}`);\n    console.log(`- Max Budget: ${this.config.maxBudget.amount} ${this.config.maxBudget.currency}`);\n    console.log(`- Symbols: ${this.config.symbols.map(s => s.pair).join(', ')}`);\n    \n    // Start the appropriate trading mode\n    try {\n      switch (this.config.tradeMode) {\n        case 'backtest':\n          if (!this.backtester) {\n            throw new Error('Backtester not initialized');\n          }\n          \n          // For backtest, we need start and end times\n          const startTime = Date.now() - (30 * 24 * 60 * 60 * 1000); // 30 days ago\n          const endTime = Date.now();\n          \n          console.log(`Running backtest from ${new Date(startTime).toISOString()} to ${new Date(endTime).toISOString()}`);\n          await this.backtester.runBacktest(startTime, endTime);\n          \n          // Backtest completes automatically\n          this.isRunning = false;\n          console.log('Backtest completed');\n          break;\n          \n        case 'papertrade':\n          if (!this.paperTrader) {\n            throw new Error('PaperTrader not initialized');\n          }\n          \n          console.log('Starting paper trading mode...');\n          await this.paperTrader.start();\n          break;\n          \n        case 'live':\n          if (!this.liveTrader) {\n            throw new Error('LiveTrader not initialized');\n          }\n          \n          console.log('Starting live trading mode...');\n          await this.liveTrader.start();\n          break;\n          \n        default:\n          throw new Error(`Unknown trade mode: ${this.config.tradeMode}`);\n      }\n    } catch (error) {\n      this.isRunning = false;\n      console.error(`Error starting bot: ${error.message}`);\n      this.notificationService.sendNotification(\n        `Failed to start bot: ${error.message}`,\n        'ERROR'\n      );\n    }\n  }\n\n  async stop(): Promise<void> {\n    if (!this.isRunning) {\n      console.log('Bot is not running');\n      return;\n    }\n    \n    console.log('Stopping Binance Spot Grid Bot...');\n    \n    try {\n      // Stop the active trading mode\n      switch (this.config.tradeMode) {\n        case 'papertrade':\n          if (this.paperTrader) {\n            this.paperTrader.stop();\n          }\n          break;\n          \n        case 'live':\n          if (this.liveTrader) {\n            await this.liveTrader.stop();\n          }\n          break;\n      }\n      \n      this.isRunning = false;\n      console.log('Bot stopped successfully');\n    } catch (error) {\n      console.error(`Error stopping bot: ${error.message}`);\n      this.notificationService.sendNotification(\n        `Error stopping bot: ${error.message}`,\n        'ERROR'\n      );\n    }\n  }\n}\n\n// CLI interface\nconst program = new Command();\n\nprogram\n  .version('1.0.0')\n  .description('Binance Spot Grid Bot')\n  .option('-c, --config <path>', 'Path to configuration file', './config.json')\n  .option('-m, --mode <mode>', 'Override trade mode (backtest, papertrade, live)')\n  .option('-s, --start-date <date>', 'Start date for backtest (YYYY-MM-DD)')\n  .option('-e, --end-date <date>', 'End date for backtest (YYYY-MM-DD)')\n  .parse(process.argv);\n\nconst options = program.opts();\n\n// Create and start the bot\nasync function main() {\n  try {\n    const app = new GridBotApp(options.config);\n    \n    // Override trade mode if specified\n    if (options.mode) {\n      app.config.tradeMode = options.mode;\n    }\n    \n    await app.start();\n  } catch (error) {\n    console.error('Failed to start application:', error);\n    process.exit(1);\n  }\n}\n\nmain();\n```",
        "testStrategy": "1. Test command-line interface with different options\n2. Verify correct initialization of all components\n3. Test graceful shutdown with SIGINT and SIGTERM signals\n4. Verify error handling for configuration and initialization errors\n5. Test mode switching functionality\n6. Verify application lifecycle management",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-08T13:25:37.430Z",
      "updated": "2025-07-15T09:35:17.708Z",
      "description": "Tasks for master context"
    }
  }
}